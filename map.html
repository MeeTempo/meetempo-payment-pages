<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Carte MeeTempers - MeeTempo</title>
  <meta http-equiv="Content-Security-Policy" 
      content="default-src 'self'; 
               img-src https: data: blob:; 
               script-src 'self' https://js.api.here.com 'unsafe-inline' 'unsafe-eval'; 
               style-src 'self' 'unsafe-inline' https://fonts.googleapis.com https://js.api.here.com; 
               font-src https://fonts.gstatic.com https://js.api.here.com; 
               worker-src blob:; 
               connect-src 'self' blob: https://api.meetempo.com https://*.hereapi.com https://js.api.here.com;">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600;700;800&display=swap" rel="stylesheet">
  
  <!-- HERE Maps -->
  <link rel="stylesheet" type="text/css" href="https://js.api.here.com/v3/3.1/mapsjs-ui.css" />
  <script src="https://js.api.here.com/v3/3.1/mapsjs-core.js"></script>
  <script src="https://js.api.here.com/v3/3.1/mapsjs-service.js"></script>
  <script src="https://js.api.here.com/v3/3.1/mapsjs-ui.js"></script>
  <script src="https://js.api.here.com/v3/3.1/mapsjs-mapevents.js"></script>
  <script src="https://js.api.here.com/v3/3.1/mapsjs-clustering.js"></script>
  
  <style>
    :root {
      --mt-dark: #030E4F;
      --mt-accent: #F49F1C;
      --mt-bg: #0a133f;
      --mt-card: #0e184f;
      --mt-text: #ffffff;
      --mt-muted: #c9d1ff;
    }
    
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    
    body {
      font-family: Montserrat, sans-serif;
      background: var(--mt-bg);
      color: var(--mt-text);
      overflow: hidden;
      height: 100vh;
      touch-action: pan-y;
    }
    
    /* Top Bar */
    .top-bar {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      height: 60px;
      background: linear-gradient(160deg, #030E4F 0%, #0a133f 100%);
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 20px;
      box-shadow: 0 2px 20px rgba(0,0,0,0.3);
      z-index: 1000;
    }
    
    .logo-section {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    
    .logo-badge {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      background: conic-gradient(from 0deg, var(--mt-accent), #ffca63, var(--mt-accent));
      display: flex;
      align-items: center;
      justify-content: center;
      color: #111;
      font-weight: 800;
      font-size: 14px;
    }
    
    .top-bar h1 {
      font-size: 18px;
      font-weight: 700;
    }
    
    .stats {
      display: flex;
      align-items: center;
      gap: 12px;
      font-size: 13px;
    }
    
    .stat-item {
      display: flex;
      align-items: center;
      gap: 6px;
      background: rgba(255,255,255,0.1);
      padding: 6px 10px;
      border-radius: 16px;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .stat-item:hover {
      background: rgba(255,255,255,0.15);
    }
    
    /* üî• NOUVEAU : Barre recherche centr√©e style HERE */
    .search-bar {
      position: fixed;
      top: 70px;
      left: 50%;
      transform: translateX(-50%);
      width: 90%;
      max-width: 500px;
      z-index: 999;
    }
    
    .search-wrapper {
      display: flex;
      gap: 8px;
      background: rgba(255, 255, 255, 0.98);
      backdrop-filter: blur(10px);
      border-radius: 16px;
      padding: 12px 16px;
      box-shadow: 0 4px 30px rgba(0, 0, 0, 0.2);
    }

    /* üî• NOUVEAU : Autocomplete search */
.search-autocomplete-results {
  display: none;
  position: absolute;
  top: calc(100% + 8px);
  left: 0;
  right: 0;
  background: rgba(14, 24, 79, 0.98);
  border: 2px solid var(--mt-accent);
  border-radius: 12px;
  max-height: 400px;
  overflow-y: auto;
  z-index: 10000;
  box-shadow: 0 8px 32px rgba(0,0,0,0.6);
}

.search-autocomplete-results.show {
  display: block;
}

.search-autocomplete-item {
  padding: 12px 16px;
  cursor: pointer;
  transition: all 0.2s;
  border-bottom: 1px solid rgba(255,255,255,0.05);
  display: flex;
  align-items: start;
  gap: 12px;
}

.search-autocomplete-item:last-child {
  border-bottom: none;
}

.search-autocomplete-item:hover {
  background: rgba(244, 159, 28, 0.2);
}

.search-autocomplete-icon {
  font-size: 20px;
  flex-shrink: 0;
}

.search-autocomplete-content {
  flex: 1;
}

.search-autocomplete-title {
  font-size: 14px;
  font-weight: 600;
  color: var(--mt-text);
  margin-bottom: 4px;
}

.search-autocomplete-subtitle {
  font-size: 12px;
  color: var(--mt-muted);
}

.search-autocomplete-loading {
  padding: 16px;
  text-align: center;
  color: var(--mt-muted);
  font-size: 14px;
}
    
    .search-icon {
      font-size: 20px;
      color: #666;
    }
    
    #citySearchInput {
      flex: 1;
      border: none;
      background: transparent;
      font-size: 16px;
      font-family: 'Montserrat', sans-serif;
      color: #1a1a1a;
      outline: none;
    }
    
    #citySearchInput::placeholder {
      color: #999;
    }
    
    /* Distance Selector - repositionn√© √† droite */
    .distance-selector {
      position: fixed;
      top: 140px;
      right: 20px;
      background: linear-gradient(160deg, #030E4F 0%, #0a133f 100%);
      border: 1px solid rgba(255,255,255,0.12);
      backdrop-filter: blur(6px);
      border-radius: 12px;
      padding: 12px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.3);
      z-index: 999;
    }
    
    .distance-label {
      font-size: 11px;
      color: var(--mt-muted);
      font-weight: 600;
      text-align: center;
      margin-bottom: 8px;
    }
    
    .distance-buttons {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
    }
    
    .distance-btn {
      padding: 6px 12px;
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 8px;
      background: rgba(255,255,255,0.08);
      color: var(--mt-text);
      font-size: 11px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      font-family: inherit;
    }
    
    .distance-btn:hover {
      background: rgba(255,255,255,0.15);
    }
    
    .distance-btn.active {
      background: var(--mt-accent);
      color: #111;
      border-color: var(--mt-accent);
    }
    
    .distance-btn.auto {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: #fff;
      border-color: transparent;
    }

    /* üî• NOUVEAU : Bouton Ma Position */
.my-location-btn {
  position: fixed;
  top: 230px;
  right: 20px;
  width: 48px;
  height: 48px;
  background: linear-gradient(160deg, #030E4F 0%, #0a133f 100%);
  border: 1px solid rgba(255,255,255,0.12);
  backdrop-filter: blur(6px);
  border-radius: 50%;
  font-size: 24px;
  cursor: pointer;
  transition: all 0.2s;
  z-index: 999;
  box-shadow: 0 4px 20px rgba(0,0,0,0.3);
  display: flex;
  align-items: center;
  justify-content: center;
}

.my-location-btn:hover {
  background: var(--mt-accent);
  transform: scale(1.1);
}

.my-location-btn:active {
  transform: scale(0.95);
}


    /* Map */
    #map {
      position: fixed;
      top: 60px;
      left: 0;
      right: 0;
      bottom: 200px;
      width: 100%;
    }
    
    /* üî• NOUVEAU : Bottom Sheet expansible */
    .bottom-sheet {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      height: 200px;
      background: linear-gradient(160deg, #030E4F 0%, #0a133f 100%);
      border-top-left-radius: 24px;
      border-top-right-radius: 24px;
      box-shadow: 0 -4px 30px rgba(0,0,0,0.4);
      z-index: 999;
      transition: height 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      overflow: hidden;
    }
    
    .bottom-sheet.expanded {
      height: 60vh;
    }
    
    .sheet-handle {
      width: 40px;
      height: 4px;
      background: rgba(255,255,255,0.3);
      border-radius: 2px;
      margin: 12px auto;
      cursor: grab;
    }
    
    .sheet-handle:active {
      cursor: grabbing;
    }
    
    .sheet-content {
      padding: 0 20px 20px;
      overflow-y: auto;
      height: calc(100% - 28px);
    }
    
    .users-grid {
      display: flex;
      gap: 16px;
      overflow-x: auto;
      padding-bottom: 10px;
    }
    
    .bottom-sheet.expanded .users-grid {
      flex-direction: column;
      overflow-x: visible;
    }
    
    .user-card {
      min-width: 280px;
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.12);
      backdrop-filter: blur(6px);
      border-radius: 16px;
      padding: 16px;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .bottom-sheet.expanded .user-card {
      min-width: 100%;
    }
    
    .user-card:hover {
      transform: translateY(-4px);
      box-shadow: 0 8px 25px rgba(244,159,28,0.3);
      border-color: var(--mt-accent);
    }
    
    .user-card.active {
      border-color: var(--mt-accent);
      box-shadow: 0 0 0 2px rgba(244,159,28,0.3);
    }
    
    .user-header {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 12px;
    }
    
    .user-avatar {
      width: 44px;
      height: 44px;
      border-radius: 50%;
      background: conic-gradient(from 0deg, var(--mt-accent), #ffca63, var(--mt-accent));
      display: flex;
      align-items: center;
      justify-content: center;
      color: #111;
      font-weight: 700;
      font-size: 16px;
      flex-shrink: 0;
    }
    
    .user-info {
      flex: 1;
    }
    
    .user-info h3 {
      font-size: 16px;
      font-weight: 700;
      margin-bottom: 2px;
    }
    
    .user-distance {
      font-size: 12px;
      color: var(--mt-muted);
    }
    
    .user-suggestion {
      font-size: 14px;
      margin-bottom: 8px;
      color: #ebefff;
      line-height: 1.4;
    }
    
    .user-location {
      font-size: 13px;
      color: var(--mt-muted);
      display: flex;
      align-items: center;
      gap: 4px;
      margin-bottom: 12px;
    }
    
    .user-actions {
      display: flex;
      gap: 8px;
    }
    
    .btn {
      flex: 1;
      padding: 8px 12px;
      border: none;
      border-radius: 8px;
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      font-family: inherit;
    }
    
    .btn-primary {
      background: var(--mt-accent);
      color: #111;
    }
    
    .btn-primary:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(244,159,28,0.4);
    }
    
    .btn-secondary {
      background: rgba(255,255,255,0.1);
      color: var(--mt-text);
      border: 1px solid rgba(255,255,255,0.2);
    }
    
    .btn-secondary:hover {
      background: rgba(255,255,255,0.15);
    }
    
    /* Loading */
    .loading {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(160deg, #030E4F 0%, #0a133f 100%);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 2000;
    }
    
    .spinner {
      width: 50px;
      height: 50px;
      border: 4px solid rgba(255,255,255,0.1);
      border-top-color: var(--mt-accent);
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
      margin-bottom: 20px;
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    .loading-text {
      font-size: 16px;
      color: var(--mt-muted);
    }
    
    /* Error */
    .error-screen {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(160deg, #030E4F 0%, #0a133f 100%);
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 20px;
      z-index: 2000;
    }
    
    .error-screen.show {
      display: flex;
    }
    
    .error-content {
      max-width: 400px;
    }
    
    .error-icon {
      font-size: 64px;
      margin-bottom: 20px;
    }
    
    .error-title {
      font-size: 24px;
      font-weight: 700;
      margin-bottom: 12px;
    }
    
    .error-message {
      font-size: 16px;
      color: var(--mt-muted);
      margin-bottom: 24px;
      line-height: 1.5;
    }
    
    /* üî• NOUVEAU : Panneau Suggestions */
    .suggestions-panel {
      position: fixed;
      top: 60px;
      right: -400px;
      width: 400px;
      height: calc(100vh - 60px);
      background: linear-gradient(160deg, #030E4F 0%, #0a133f 100%);
      box-shadow: -4px 0 30px rgba(0,0,0,0.4);
      z-index: 1001;
      transition: right 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      display: flex;
      flex-direction: column;
    }
    
    .suggestions-panel.open {
      right: 0;
    }
    
    .panel-header {
      padding: 20px;
      border-bottom: 1px solid rgba(255,255,255,0.1);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .panel-header h2 {
      font-size: 18px;
      font-weight: 700;
      margin: 0;
    }
    
    .close-btn {
      background: rgba(255,255,255,0.1);
      border: none;
      border-radius: 50%;
      width: 32px;
      height: 32px;
      font-size: 18px;
      cursor: pointer;
      color: var(--mt-text);
      transition: all 0.2s;
    }
    
    .close-btn:hover {
      background: rgba(255,255,255,0.2);
      transform: rotate(90deg);
    }
    
    .panel-content {
      flex: 1;
      overflow-y: auto;
      padding: 16px;
    }
    
    .suggestion-item {
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 12px;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .suggestion-item:hover {
      transform: translateX(-4px);
      border-color: var(--mt-accent);
      box-shadow: 0 4px 20px rgba(244,159,28,0.3);
    }
    
    .suggestion-item-title {
      font-size: 15px;
      font-weight: 600;
      margin-bottom: 8px;
      color: var(--mt-text);
    }
    
    .suggestion-item-meta {
      font-size: 12px;
      color: var(--mt-muted);
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
    }
    
    .load-more-btn {
      margin: 16px;
      padding: 12px;
      background: var(--mt-accent);
      color: #111;
      border: none;
      border-radius: 10px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      width: calc(100% - 32px);
    }
    
    .load-more-btn:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(244,159,28,0.4);
    }
    
    .load-more-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .panel-empty {
      text-align: center;
      padding: 40px 20px;
      color: var(--mt-muted);
    }
    
    .panel-empty-icon {
      font-size: 48px;
      margin-bottom: 12px;
    }
    
    /* Responsive */
@media (max-width: 640px) {
  .top-bar {
    height: 56px;
    padding: 0 12px;
  }
  
  .top-bar h1 {
    font-size: 16px;
  }
  
  .stats {
    gap: 8px;
    font-size: 12px;
  }
  
  .stat-item {
    padding: 4px 8px;
  }
  
  .search-bar {
    top: 66px;
    width: calc(100% - 24px);
  }
  
  .search-wrapper {
    padding: 10px 12px;
  }
  
  .distance-selector {
    top: 135px;
    right: 12px;
  }
  
  #map {
    top: 56px;
  }
  
  /* üî• NOUVEAU : Bouton ma position mobile */
  .my-location-btn {
    top: 210px;
    right: 12px;
    width: 44px;
    height: 44px;
    font-size: 20px;
  }
}

  </style>
</head>
<body>
  <!-- Loading Screen -->
  <div id="loading" class="loading">
    <div class="spinner"></div>
    <div class="loading-text">Chargement de la carte...</div>
  </div>
  
  <!-- Error Screen -->
  <div id="errorScreen" class="error-screen">
    <div class="error-content">
      <div class="error-icon">‚ùå</div>
      <h2 class="error-title" id="errorTitle">Erreur</h2>
      <p class="error-message" id="errorMessage">Une erreur est survenue</p>
      <button class="btn btn-primary" onclick="window.location.href='https://chatgpt.com/g/g-68f522fa42b08191978685b03a9b03c2-meetempo-test-oct19'">
        Retour √† MeeTempo
      </button>
    </div>
  </div>
  
  <!-- Top Bar -->
  <div class="top-bar">
    <div class="logo-section">
      <div class="logo-badge">MT</div>
      <h1>üó∫ Carte MeeTempers</h1>
    </div>
    <div class="stats" id="statsHeader">
      <div class="stat-item">
        <span>üìç</span>
        <span id="locationText">Paris</span>
      </div>
      <div class="stat-item">
        <span>üë•</span>
        <span id="userCount">0</span>
      </div>
      <div class="stat-item" onclick="openSuggestionsList()" style="cursor: pointer; transition: all 0.2s;" onmouseover="this.style.background='rgba(244,159,28,0.2)'" onmouseout="this.style.background='rgba(255,255,255,0.1)'">
        <span>üìã</span>
        <span id="suggestionCount">0</span>
      </div>
      <div class="stat-item">
        <span>üìè</span>
        <span id="radiusText">20 km</span>
      </div>
      <div class="stat-item" id="visibilityToggle" onclick="toggleVisibility()">
        <span id="visibilityIcon">üëÅÔ∏è</span>
        <span id="visibilityText">Visible</span>
      </div>
    </div>
  </div>
  
  <!-- üî• NOUVEAU : Barre recherche centr√©e -->
<div class="search-bar">
  <div class="search-wrapper">
    <span class="search-icon">üîç</span>
    <input 
      type="text" 
      id="citySearchInput" 
      placeholder="O√π aller ?"
      autocomplete="off"
    >
    <!-- üî• NOUVEAU : Autocomplete r√©sultats -->
    <div id="searchAutocomplete" class="search-autocomplete-results"></div>
  </div>
</div>
  
  <!-- Distance Selector -->
  <div class="distance-selector">
    <div class="distance-label">RAYON</div>
    <div class="distance-buttons">
      <button class="distance-btn" data-radius="5">5 km</button>
      <button class="distance-btn" data-radius="10">10 km</button>
      <button class="distance-btn active" data-radius="20">20 km</button>
      <button class="distance-btn" data-radius="50">50 km</button>
    </div>
  </div>

  <!-- üî• NOUVEAU : Bouton Ma Position -->
<button class="my-location-btn" onclick="goToMyLocation()" title="Recentrer sur ma position">
  üéØ
</button>
  
  <!-- Map -->
  <div id="map"></div>
  
  <!-- üî• NOUVEAU : Bottom Sheet expansible -->
  <div class="bottom-sheet" id="bottomSheet">
    <div class="sheet-handle" id="sheetHandle"></div>
    <div class="sheet-content">
      <div class="users-grid" id="usersGrid"></div>
    </div>
  </div>

  <!-- üî• NOUVEAU : Panneau Suggestions -->
  <div class="suggestions-panel" id="suggestionsPanel">
    <div class="panel-header">
      <h2>üìã Suggestions √† proximit√©</h2>
      <button class="close-btn" onclick="closeSuggestionsPanel()">‚úï</button>
    </div>
    <div class="panel-content" id="suggestionsList">
      <!-- Liste remplie dynamiquement -->
    </div>
    <button class="load-more-btn" id="loadMoreBtn" onclick="loadMoreSuggestions()" style="display: none;">
      üîç Voir plus loin
    </button>
  </div>

  <script>
    const API_BASE = 'https://api.meetempo.com';
    const params = new URLSearchParams(location.search);
    const token = params.get('token');
    
    let HERE_API_KEY = null;
    let map;
    let ui;
    let userGpsLocation = { lat: 48.8566, lng: 2.3522, source: 'default' }; // üî• NOUVEAU : Position GPS r√©elle
    let currentLocation = { lat: 48.8566, lng: 2.3522 }; // Centre carte actuel
    let currentRadius = 20;
    let markers = [];
    let usersData = [];
    let currentVisibility = 'visible';
    let clusteringLayer = null;
    let isManualRadius = false; // üî• NOUVEAU : Mode manuel vs auto
    let suggestionsData = []; // üî• NOUVEAU : Cache suggestions
    let suggestionsRadius = 20; // üî• NOUVEAU : Rayon actuel suggestions
    let reloadTimeout = null; // üî• NOUVEAU : Debounce reload carte
    let searchAutocompleteTimeout = null; // üî• NOUVEAU : Debounce autocomplete recherche
    let lastReverseGeocodingCall = 0; // üî• NOUVEAU : Throttle reverse geocoding
    
    const MARKER_COLORS = [
      '#F49F1C', '#3B82F6', '#10B981', '#8B5CF6',
      '#EF4444', '#F59E0B', '#06B6D4', '#EC4899'
    ];
    
    // üî• MODIFI√â : Ouvrir panneau suggestions (utilise suggestionsData d√©j√† charg√©)
    function openSuggestionsList() {
      const panel = document.getElementById('suggestionsPanel');
      panel.classList.add('open');
      
      // üî• Afficher suggestions d√©j√† charg√©es
      displaySuggestionsList();
    }
    
    // üî• NOUVEAU : Afficher liste suggestions
    function displaySuggestionsList() {
      const listContainer = document.getElementById('suggestionsList');
      
      if (!suggestionsData || suggestionsData.length === 0) {
        listContainer.innerHTML = `
          <div class="panel-empty">
            <div class="panel-empty-icon">üì≠</div>
            <div style="font-weight:600;margin-bottom:8px;">Aucune suggestion</div>
            <div style="font-size:13px;">Aucune suggestion dans ce rayon</div>
          </div>
        `;
        document.getElementById('loadMoreBtn').style.display = 'none';
      } else {
        listContainer.innerHTML = suggestionsData.map(sugg => `
  <div class="suggestion-item" onclick="highlightSuggestion('${sugg.id}')">
    <div class="suggestion-item-title">${escapeHTML(sugg.title)}</div>
    <div class="suggestion-item-meta">
      <span>üë§ ${escapeHTML(sugg.user_pseudo)}</span>
      <span>üìç ${sugg.distance_km} km</span>
      <span>üèôÔ∏è ${escapeHTML(sugg.city || sugg.location_name || '?')}</span>  // üî• FIX
    </div>
  </div>
`).join('');
        
        // üî• MODIFI√â : Afficher bouton "Voir plus" si suggestions trouv√©es
        const loadMoreBtn = document.getElementById('loadMoreBtn');
        if (currentRadius < 200) {
          loadMoreBtn.style.display = 'block';
          loadMoreBtn.textContent = `üîç Voir plus loin (+10 km) - Rayon actuel: ${currentRadius} km`;
          loadMoreBtn.disabled = false;
        } else {
          loadMoreBtn.style.display = 'none';
        }
      }
    }
    
    // üî• NOUVEAU : Fermer panneau
    function closeSuggestionsPanel() {
      const panel = document.getElementById('suggestionsPanel');
      panel.classList.remove('open');
    }
    
    // üî• NOUVEAU : Charger suggestions
    async function loadSuggestionsNearby(radius) {
      try {
        const listContainer = document.getElementById('suggestionsList');
        listContainer.innerHTML = '<div style="text-align:center;padding:20px;color:var(--mt-muted);">Chargement...</div>';
        
        const response = await fetch(
          `${API_BASE}/suggestions/nearby?token=${token}&lat=${currentLocation.lat}&lng=${currentLocation.lng}&radius=${radius}`
        );
        
        if (!response.ok) throw new Error('Erreur chargement');
        
        const data = await response.json();
        suggestionsData = data.results || [];
        
        // Mettre √† jour compteur
        document.getElementById('suggestionCount').textContent = suggestionsData.length;
        
        // Afficher liste
        if (suggestionsData.length === 0) {
          listContainer.innerHTML = `
            <div class="panel-empty">
              <div class="panel-empty-icon">üì≠</div>
              <div style="font-weight:600;margin-bottom:8px;">Aucune suggestion</div>
              <div style="font-size:13px;">Aucune suggestion dans ce rayon</div>
            </div>
          `;
          document.getElementById('loadMoreBtn').style.display = 'none';
        } else {
          listContainer.innerHTML = suggestionsData.map(sugg => `
  <div class="suggestion-item" onclick="highlightSuggestion('${sugg.id}')">
    <div class="suggestion-item-title">${escapeHTML(sugg.title)}</div>
    <div class="suggestion-item-meta">
      <span>${sugg.activity || 'üìç'}</span>
      <span>${sugg.distance_km} km</span>
      <span>üèôÔ∏è ${escapeHTML(sugg.city || sugg.location_name || '?')}</span>  // üî• AJOUT√â
    </div>
  </div>
`).join('');
          
          // Afficher bouton "Voir plus" si suggestions trouv√©es
          document.getElementById('loadMoreBtn').style.display = 'block';
        }
        
      } catch (err) {
        console.error('Erreur suggestions:', err);
        document.getElementById('suggestionsList').innerHTML = `
          <div class="panel-empty">
            <div class="panel-empty-icon">‚ùå</div>
            <div>Erreur chargement</div>
          </div>
        `;
      }
    }
    
    // üî• MODIFI√â : Augmenter rayon carte (+10 km)
    async function loadMoreSuggestions() {
      const btn = document.getElementById('loadMoreBtn');
      btn.disabled = true;
      btn.textContent = '‚è≥ Chargement...';
      
      // üî• Augmenter rayon de 10 km
      currentRadius += 10;
      
      // üî• Mettre √† jour UI bouton rayon
      document.querySelectorAll('.distance-btn').forEach(b => {
        b.classList.remove('active', 'auto');
      });
      document.getElementById('radiusText').textContent = `${currentRadius} km (√©largi)`;
      
      // üî• NOUVEAU : D√©zoomer carte selon rayon
      let newZoom;
      if (currentRadius <= 5) newZoom = 14;
      else if (currentRadius <= 10) newZoom = 13;
      else if (currentRadius <= 20) newZoom = 12;
      else if (currentRadius <= 50) newZoom = 11;
      else if (currentRadius <= 100) newZoom = 10;
      else if (currentRadius <= 200) newZoom = 8;
      else newZoom = 6;
      
      map.setZoom(newZoom, true);
      
      // üî• Recharger users/suggestions avec nouveau rayon
      await loadNearbyUsers();
      
      // üî• R√©afficher panneau suggestions
      displaySuggestionsList();
      
      btn.disabled = false;
    }
    
    // üî• MODIFI√â : Highlight suggestion + fermer panneau
    function highlightSuggestion(suggestionId) {
      const sugg = suggestionsData.find(s => s.id === suggestionId);
      if (!sugg) {
        console.warn(`‚ö†Ô∏è Suggestion ${suggestionId} introuvable`);
        return;
      }
      
      // üî• Centrer + zoomer sur la suggestion
      map.setCenter({ lat: sugg.lat, lng: sugg.lng });
      map.setZoom(15, true); // Animation smooth
      
      // üî• Fermer le panneau suggestions (pour voir la carte)
      const panel = document.getElementById('suggestionsPanel');
      panel.classList.remove('open');
      
      // üî• Highlight la carte utilisateur correspondante dans le bottom sheet
      const userIndex = usersData.findIndex(u => 
        u.suggestion_id === suggestionId || 
        (u.location.lat === sugg.lat && u.location.lng === sugg.lng)
      );
      
      if (userIndex !== -1) {
        highlightUserCard(userIndex);
      }
      
      console.log(`üìç Centr√© sur: ${sugg.title.substring(0, 50)}...`);
    }
    
    function escapeHTML(str) {
      if (!str) return '';
      const div = document.createElement('div');
      div.textContent = str;
      return div.innerHTML;
    }
    
    function getMarkerColor(index) {
      return MARKER_COLORS[index % MARKER_COLORS.length];
    }
    
    function getAffinityColor(score) {
      if (score >= 80) return '#10B981';
      if (score >= 60) return '#F49F1C';
      if (score >= 40) return '#3B82F6';
      return '#9CA3AF';
    }
    
    // üî• NOUVEAU : Ic√¥ne cluster avec chiffre
    function createClusterIcon(count) {
      return `<svg width="60" height="60" xmlns="http://www.w3.org/2000/svg">
        <circle cx="30" cy="30" r="25" fill="#F49F1C" opacity="0.9"/>
        <circle cx="30" cy="30" r="25" fill="none" stroke="#fff" stroke-width="2"/>
        <text x="30" y="38" text-anchor="middle" 
              font-family="Montserrat, sans-serif"
              font-size="18" font-weight="800" fill="#111">
          ${count}
        </text>
      </svg>`;
    }
    
    function createDropletIcon(color, affinityScore = 50, plan = "free", visibility = "visible") {
      const ringColor = getAffinityColor(affinityScore);
      const ringWidth = 4;
      
      let haloStroke = 'none';
      let haloWidth = 0;
      let haloOpacity = 1;
      
      if (plan === 'vip' && visibility === 'visible') {
        haloStroke = '#F49F1C';
        haloWidth = 8;
        haloOpacity = 0.85;
      } else if (visibility === 'discret') {
        haloStroke = '#1E40AF';
        haloWidth = 8;
        haloOpacity = 0.85;
      }
      
      return `<svg width="64" height="70" xmlns="http://www.w3.org/2000/svg">
        ${haloWidth > 0 ? `
        <circle cx="32" cy="28" r="28" 
                fill="none" 
                stroke="${haloStroke}" 
                stroke-width="${haloWidth}"
                opacity="${haloOpacity}"/>
        ` : ''}
        <circle cx="32" cy="28" r="20" 
                fill="none" 
                stroke="${ringColor}" 
                stroke-width="${ringWidth}"
                opacity="0.9"/>
        <path d="M32 16 C32 16, 22 28, 22 36 C22 41, 26 46, 32 46 C38 46, 42 41, 42 36 C42 28, 32 16, 32 16 Z" 
              fill="${color}" 
              stroke="white" 
              stroke-width="2.5"
              stroke-linejoin="round"/>
        <text x="32" y="66" 
              font-family="Montserrat, sans-serif" 
              font-size="10" 
              font-weight="700" 
              fill="${ringColor}" 
              text-anchor="middle">
          ${affinityScore}%
        </text>
      </svg>`;
    }
    
    function showError(title, message, type = 'unknown') {
      document.getElementById('loading').style.display = 'none';
      document.getElementById('errorTitle').textContent = title;
      document.getElementById('errorMessage').textContent = message;
      document.getElementById('errorScreen').classList.add('show');
      
      if (type === 'expired') {
        setTimeout(() => {
          window.location.href = 'https://chatgpt.com/g/g-68f522fa42b08191978685b03a9b03c2-meetempo-test-oct19';
        }, 3000);
      }
    }
    
    async function init() {
      if (!token) {
        showError('Token manquant', 'Veuillez acc√©der depuis MeeTempo GPT', 'missing');
        return;
      }
      
      try {
        const sessionResponse = await fetch(`${API_BASE}/auth/session?token=${token}`);
        if (!sessionResponse.ok) {
          if (sessionResponse.status === 401) {
            showError('Session expir√©e', 'Redirection vers MeeTempo GPT...', 'expired');
          } else {
            showError('Erreur serveur', 'Service temporairement indisponible', 'server');
          }
          return;
        }
        
        const sessionData = await sessionResponse.json();
        if (!sessionData.user_id) {
          showError('Session invalide', 'Impossible de valider votre session', 'invalid');
          return;
        }
        
        const charterResponse = await fetch(`${API_BASE}/consent/status?token=${token}`);
        if (charterResponse.ok) {
          const charterData = await charterResponse.json();
          if (!charterData.accepted) {
            const returnUrl = encodeURIComponent(window.location.href);
            window.location.href = `charter.html?token=${token}&return=${returnUrl}`;
            return;
          }
        }
        
        const keyResponse = await fetch(`${API_BASE}/config/here-key?token=${token}`);
        if (!keyResponse.ok) {
          showError('Erreur configuration', 'Impossible de charger la carte', 'config');
          return;
        }
        
        const keyData = await keyResponse.json();
        HERE_API_KEY = keyData.key;
        
        await getUserLocation();
        
        const cityParam = params.get('city');
        if (cityParam) {
          try {
            const geocodeUrl = `https://geocode.search.hereapi.com/v1/geocode?q=${encodeURIComponent(cityParam)}&apiKey=${HERE_API_KEY}`;
            const response = await fetch(geocodeUrl);
            const data = await response.json();
            
            if (data.items && data.items.length > 0) {
              const position = data.items[0].position;
              currentLocation = {
                lat: position.lat,
                lng: position.lng,
                source: 'search',
                city: cityParam
              };
              console.log(`üìç Carte centr√©e sur ${cityParam}`);
            }
          } catch (err) {
            console.error('Erreur g√©ocodage:', err);
          }
        }
        
        initMap();
        setupDistanceSelector();
        setupCitySearch();
        setupBottomSheet();
        
      } catch (err) {
        console.error('Init error:', err);
        if (!navigator.onLine) {
          showError('Pas de connexion', 'V√©rifiez votre connexion internet', 'offline');
        } else {
          showError('Erreur inattendue', 'Une erreur est survenue', 'unknown');
        }
      }
    }
    
    async function getUserLocation() {
      return new Promise((resolve) => {
        if (navigator.geolocation) {
          navigator.geolocation.getCurrentPosition(
            (position) => {
              userGpsLocation = {  // üî• MODIFI√â : Sauvegarder dans userGpsLocation
              lat: position.coords.latitude,
              lng: position.coords.longitude,
              source: 'gps',
              accuracy: position.coords.accuracy
            };
            currentLocation = { ...userGpsLocation }; // Centre carte = GPS au d√©marrage
            console.log('‚úÖ GPS:', userGpsLocation);
              resolve();
            },
            (error) => {
              console.warn('‚ö†Ô∏è Geoloc failed:', error.message);
              currentLocation = {
                lat: 48.8566,
                lng: 2.3522,
                source: 'default',
                city: 'Paris'
              };
              resolve();
            },
            { timeout: 5000, enableHighAccuracy: true }
          );
        } else {
          currentLocation = {
            lat: 48.8566,
            lng: 2.3522,
            source: 'default',
            city: 'Paris'
          };
          resolve();
        }
      });
    }
    
    function setupDistanceSelector() {
  const buttons = document.querySelectorAll('.distance-btn');
  
  buttons.forEach(btn => {
    btn.addEventListener('click', () => {
      const radius = parseInt(btn.dataset.radius, 10);
      
      // UI state
      buttons.forEach(b => b.classList.remove('active', 'auto'));
      btn.classList.add('active');
      
      // √âtat logique
      currentRadius = radius;
      isManualRadius = true;
      document.getElementById('radiusText').textContent = `${radius} km`;
      
      // üî• Recentrer sur position GPS utilisateur
if (userGpsLocation && (userGpsLocation.source === 'gps' || userGpsLocation.source === 'default')) {
  const position = { lat: userGpsLocation.lat, lng: userGpsLocation.lng };
  currentLocation = { ...userGpsLocation }; // üî• NOUVEAU : R√©initialiser currentLocation
  map.setCenter(position);
  // Le zoom est d√©j√† g√©r√© juste apr√®s dans le if/else
} else {
  alert('‚ö†Ô∏è Position GPS inconnue. Utilisez le bouton üéØ pour actualiser.');
  return;
}
      
      if (radius <= 5) map.setZoom(14, true);
      else if (radius <= 10) map.setZoom(13, true);
      else if (radius <= 20) map.setZoom(12, true);
      else if (radius <= 50) map.setZoom(11, true);
      else if (radius <= 100) map.setZoom(10, true);
      else if (radius <= 200) map.setZoom(8, true);
      else map.setZoom(6, true);
      
      loadNearbyUsers();
    });
  });
}
    
    function setupCitySearch() {
  const input = document.getElementById('citySearchInput');
  const resultsDiv = document.getElementById('searchAutocomplete');
  
  // üî• NOUVEAU : Autocomplete recherche AVEC CACHE
input.addEventListener('input', async (e) => {
  const query = e.target.value.trim();
  
  // Clear timeout pr√©c√©dent
  if (searchAutocompleteTimeout) {
    clearTimeout(searchAutocompleteTimeout);
  }
  
  // Si vide, masquer r√©sultats
  if (!query || query.length < 3) {
    resultsDiv.classList.remove('show');
    return;
  }
  
  // Attendre 400ms apr√®s arr√™t de frappe
  searchAutocompleteTimeout = setTimeout(async () => {
    try {
      // Afficher loading
      resultsDiv.innerHTML = '<div class="search-autocomplete-loading">üîç Recherche...</div>';
      resultsDiv.classList.add('show');
      
      // üî• NOUVEAU : V√©rifier cache sessionStorage (1h)
      const cacheKey = `autocomplete:${query.toLowerCase()}`;
      const cached = sessionStorage.getItem(cacheKey);
      
      let data;
      
      if (cached) {
        // Cache HIT
        const cachedData = JSON.parse(cached);
        const age = Date.now() - cachedData.timestamp;
        
        if (age < 3600000) { // 1 heure
          data = cachedData.results;
          console.log(`‚úÖ Autocomplete (cache): "${query}" - ${data.items?.length || 0} r√©sultats`);
        } else {
          // Cache expir√©, supprimer
          sessionStorage.removeItem(cacheKey);
        }
      }
      
      if (!data) {
        // Cache MISS - Appel HERE Autosuggest API
        const autosuggestUrl = `https://autosuggest.search.hereapi.com/v1/autosuggest?q=${encodeURIComponent(query)}&at=${currentLocation.lat},${currentLocation.lng}&limit=6&apiKey=${HERE_API_KEY}`;
        
        const response = await fetch(autosuggestUrl);
        
        if (!response.ok) {
          throw new Error('Erreur autocomplete');
        }
        
        data = await response.json();
        
        // üî• NOUVEAU : Sauvegarder en cache
        sessionStorage.setItem(cacheKey, JSON.stringify({
          results: data,
          timestamp: Date.now()
        }));
        
        console.log(`‚úÖ Autocomplete (API): "${query}" - ${data.items?.length || 0} r√©sultats - Mis en cache`);
      }
      
      // Afficher r√©sultats
      if (data.items && data.items.length > 0) {
        resultsDiv.innerHTML = data.items.map(item => {
          const title = item.title || item.address?.label || '';
          const subtitle = item.address?.label || item.vicinity || '';
          const lat = item.position?.lat || 0;
          const lng = item.position?.lng || 0;
          
          // D√©terminer ic√¥ne selon type
          let icon = 'üìç';
          if (item.resultType === 'locality') icon = 'üèôÔ∏è';
          else if (item.resultType === 'place') icon = 'üè¢';
          else if (item.resultType === 'street') icon = 'üõ£Ô∏è';
          
          // Escape pour onclick
          const safeLat = lat.toFixed(6);
          const safeLng = lng.toFixed(6);
          const safeTitle = title.replace(/'/g, "\\'").replace(/"/g, '&quot;');
          
          return `
            <div class="search-autocomplete-item" onclick="selectSearchLocation(${safeLat}, ${safeLng}, '${safeTitle}')">
              <div class="search-autocomplete-icon">${icon}</div>
              <div class="search-autocomplete-content">
                <div class="search-autocomplete-title">${escapeHTML(title)}</div>
                <div class="search-autocomplete-subtitle">${escapeHTML(subtitle)}</div>
              </div>
            </div>
          `;
        }).join('');
      } else {
        resultsDiv.innerHTML = '<div class="search-autocomplete-loading">Aucun r√©sultat</div>';
      }
      
    } catch (err) {
      console.error('Erreur autocomplete recherche:', err);
      resultsDiv.innerHTML = '<div class="search-autocomplete-loading">‚ùå Erreur recherche</div>';
    }
  }, 400);
});
  
  // Conserver recherche Enter (fallback)
  input.addEventListener('keypress', async (e) => {
    if (e.key === 'Enter') {
      const cityQuery = input.value.trim();
      
      if (!cityQuery) return;
      
      try {
        const geocodeUrl = `https://geocode.search.hereapi.com/v1/geocode?q=${encodeURIComponent(cityQuery)}&apiKey=${HERE_API_KEY}`;
        const response = await fetch(geocodeUrl);
        const data = await response.json();
        
        if (data.items && data.items.length > 0) {
          const position = data.items[0].position;
          const cityName = data.items[0].address.city || cityQuery;
          
          selectSearchLocation(position.lat, position.lng, cityName);
          
        } else {
          alert(`‚ùå Ville "${cityQuery}" introuvable`);
        }
        
      } catch (err) {
        console.error('Erreur recherche:', err);
        alert('‚ùå Erreur lors de la recherche');
      }
    }
  });
}

// üî• NOUVEAU : S√©lectionner un r√©sultat autocomplete
function selectSearchLocation(lat, lng, name) {
  const input = document.getElementById('citySearchInput');
  const resultsDiv = document.getElementById('searchAutocomplete');
  
  // Masquer autocomplete
  resultsDiv.classList.remove('show');
  
  // Vider input
  input.value = '';
  input.blur();
  
  // Mettre √† jour position
  currentLocation.lat = lat;
  currentLocation.lng = lng;
  currentLocation.city = name;
  
  // Recentrer carte
  map.setCenter({ lat, lng });
  map.setZoom(13);
  
  // Mettre √† jour indicateur
  document.getElementById('locationText').textContent = name;
  
  // Recharger users
  loadNearbyUsers();
  
  console.log(`üîç Recherche: ${name} (${lat}, ${lng})`);
}

// Helper: Escape HTML
function escapeHTML(str) {
  if (!str) return '';
  const div = document.createElement('div');
  div.textContent = str;
  return div.innerHTML;
}

// Masquer autocomplete si clic ext√©rieur
document.addEventListener('click', (e) => {
  if (!e.target.closest('.search-wrapper')) {
    const resultsDiv = document.getElementById('searchAutocomplete');
    if (resultsDiv) resultsDiv.classList.remove('show');
  }
});
    
    // üî• NOUVEAU : Setup bottom sheet expansible
    function setupBottomSheet() {
      const sheet = document.getElementById('bottomSheet');
      const handle = document.getElementById('sheetHandle');
      let startY = 0;
      let currentHeight = 200;
      
      handle.addEventListener('touchstart', (e) => {
        startY = e.touches[0].clientY;
      });
      
      handle.addEventListener('touchmove', (e) => {
        const deltaY = startY - e.touches[0].clientY;
        const newHeight = currentHeight + deltaY;
        
        if (newHeight >= 200 && newHeight <= window.innerHeight * 0.6) {
          sheet.style.height = `${newHeight}px`;
        }
      });
      
      handle.addEventListener('touchend', (e) => {
        currentHeight = parseInt(sheet.style.height) || 200;
        
        if (currentHeight > 300) {
          sheet.classList.add('expanded');
          sheet.style.height = '60vh';
          currentHeight = window.innerHeight * 0.6;
        } else {
          sheet.classList.remove('expanded');
          sheet.style.height = '200px';
          currentHeight = 200;
        }
      });
      
      // Click sur handle toggle
      handle.addEventListener('click', () => {
        if (sheet.classList.contains('expanded')) {
          sheet.classList.remove('expanded');
          sheet.style.height = '200px';
          currentHeight = 200;
        } else {
          sheet.classList.add('expanded');
          sheet.style.height = '60vh';
          currentHeight = window.innerHeight * 0.6;
        }
      });
    }
    
    async function initMap() {
      const platform = new H.service.Platform({
        apikey: HERE_API_KEY
      });
      
      const defaultLayers = platform.createDefaultLayers();
      
      map = new H.Map(
  document.getElementById('map'),
  defaultLayers.vector.normal.map,
  {
    center: currentLocation,
    zoom: 13,
    pixelRatio: window.devicePixelRatio || 1,
    // üî• NOUVEAU : Limiter zoom pour √©conomiser tiles
    restrictions: {
      minZoom: 8,   // √âviter zoom continent
      maxZoom: 15   // √âviter zoom rue
    }
  }
);

const behavior = new H.mapevents.Behavior(new H.mapevents.MapEvents(map));
ui = H.ui.UI.createDefault(map, defaultLayers);

// üî• NOUVEAU : Double-clic sur carte ‚Üí Mettre √† jour ville
map.addEventListener('dbltap', async (evt) => {
  const coords = map.screenToGeo(
    evt.currentPointer.viewportX,
    evt.currentPointer.viewportY
  );
  
  if (coords) {
    await updateLocationIndicator(coords.lat, coords.lng);
  }
});

// üî• MODIFI√â : Listener drag/zoom ‚Üí rafra√Æchir markers (avec debounce)
map.addEventListener('mapviewchangeend', async function() {
  // üî• Annuler timer pr√©c√©dent
  if (reloadTimeout) {
    clearTimeout(reloadTimeout);
  }
  
  reloadTimeout = setTimeout(async () => {
  // Mettre √† jour position actuelle
  const center = map.getCenter();
  currentLocation.lat = center.lat;
  currentLocation.lng = center.lng;
  
  // üî• NOUVEAU : Mettre √† jour indicateur ville
  await updateLocationIndicator(center.lat, center.lng);
  
  // Recharger users √† la nouvelle position
  await loadNearbyUsers();
}, 800);
  
  // Ancien code zoom auto-ajuste (garde si besoin, sinon supprime)
  if (isManualRadius) return;
  
  const zoom = map.getZoom();
  let radiusNeeded;
  if (zoom <= 6) radiusNeeded = 500;
  else if (zoom <= 8) radiusNeeded = 200;
  else if (zoom <= 10) radiusNeeded = 100;
  else if (zoom <= 12) radiusNeeded = 50;
  else if (zoom <= 14) radiusNeeded = 20;
  else radiusNeeded = 10;
  
  if (radiusNeeded > currentRadius) {
    currentRadius = radiusNeeded;
    updateDistanceButtons(radiusNeeded);
    document.getElementById('radiusText').textContent = `${radiusNeeded} km (auto)`;
    console.log(`üîÑ Auto-ajust√©: ${radiusNeeded} km (zoom ${zoom})`);
  }
});
  
        window.addEventListener('resize', () => {
        if (map) map.getViewPort().resize();
      });
      
      const userIcon = new H.map.Icon(createDropletIcon('#3B82F6', 100, 'premium', 'visible'), { 
        size: { w: 64, h: 70 },
        anchor: { x: 32, y: 66 }
      });
      
      const userMarker = new H.map.Marker(currentLocation, { icon: userIcon });
      map.addObject(userMarker);
      
      loadNearbyUsers();
    }
    
    // üî• NOUVEAU : Calculer distance entre 2 points
    function calculateDistance(lat1, lng1, lat2, lng2) {
      const R = 6371; // Rayon Terre en km
      const dLat = (lat2 - lat1) * Math.PI / 180;
      const dLng = (lng2 - lng1) * Math.PI / 180;
      const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                Math.sin(dLng/2) * Math.sin(dLng/2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
      return R * c;
    }
    
    // üî• NOUVEAU : Update distance buttons (mode auto)
    function updateDistanceButtons(radius) {
      const buttons = document.querySelectorAll('.distance-btn');
      buttons.forEach(b => {
        b.classList.remove('active', 'auto');
        const btnRadius = parseInt(b.dataset.radius);
        if (btnRadius === radius || (btnRadius > radius && btnRadius < radius + 10)) {
          b.classList.add('auto');
        }
      });
    }
    
    async function loadNearbyUsers() {
      try {
        document.getElementById('loading').style.display = 'flex';
        
        const response = await fetch(
          `${API_BASE}/users/nearby?lat=${currentLocation.lat}&lng=${currentLocation.lng}&radius=${currentRadius}&token=${token}`
        );
        
        if (!response.ok) {
          if (response.status === 401) {
            showError('Session expir√©e', 'Redirection...', 'expired');
          } else if (response.status === 429) {
            // üî• MODIFI√â : Message rassurant + auto-retry
            document.getElementById('loading').style.display = 'flex';
            document.querySelector('.loading-text').textContent = '‚è≥ Carte tr√®s sollicit√©e, rechargement dans 10s...';
            
            setTimeout(() => {
              loadNearbyUsers(); // Retry automatique
            }, 10000);
            return;
          } else {
            throw new Error('Failed to load');
          }
          return;
        }
        
        const data = await response.json();
        usersData = data.users || [];
        
        document.getElementById('userCount').textContent = `${usersData.length}`;
        document.getElementById('locationText').textContent = currentLocation.city || 'Paris';
        
        // üî• NOUVEAU : Extraire suggestions depuis users
        suggestionsData = usersData
          .filter(u => u.latest_suggestion)
          .map(u => ({
            id: u.suggestion_id || u.id,
            title: u.latest_suggestion,
            distance_km: u.distance,
            lat: u.location.lat,
            lng: u.location.lng,
            user_pseudo: u.pseudo,
            user_city: u.city,
            suggestion_date: u.suggestion_date,
            suggestion_time: u.suggestion_time
          }))
          .sort((a, b) => {
            // üî• TRI INTELLIGENT : < 24h prioritaire, sinon distance
            const now = new Date();
            const in24h = new Date(now.getTime() + 24 * 60 * 60 * 1000);
            
            // Parser dates suggestions
            const dateA = a.suggestion_date ? new Date(a.suggestion_date) : null;
            const dateB = b.suggestion_date ? new Date(b.suggestion_date) : null;
            
            const isASoon = dateA && dateA <= in24h && dateA >= now;
            const isBSoon = dateB && dateB <= in24h && dateB >= now;
            
            // Cas 1 : Les deux < 24h ‚Üí Trier par date/heure
            if (isASoon && isBSoon) {
              return dateA - dateB;
            }
            
            // Cas 2 : Seulement A < 24h ‚Üí A en premier
            if (isASoon) return -1;
            
            // Cas 3 : Seulement B < 24h ‚Üí B en premier
            if (isBSoon) return 1;
            
            // Cas 4 : Aucun < 24h ‚Üí Trier par distance
            return a.distance_km - b.distance_km;
          });
        
        // üî• Mettre √† jour compteur suggestions
        document.getElementById('suggestionCount').textContent = suggestionsData.length;
        
        // üî• NOUVEAU : Clustering adaptatif selon zoom
        const currentZoom = map.getZoom();
        addMarkersWithClustering(usersData, currentZoom);
        populateUserCards(usersData, currentZoom);

        document.getElementById('loading').style.display = 'none';
                
      } catch (err) {
        console.error('Error loading:', err);
        showError('Erreur chargement', 'Impossible de charger les MeeTempers', 'load');
      }
    }

    // üî• NOUVEAU : G√©n√©rer badge participants selon r√®gles
    function generateParticipantsBadge(user) {
      // Si pas de structure participants, skip
      if (!user.participants || !user.participants.min || !user.participants.max) {
        return '';
      }
      
      const min = user.participants.min;
      const max = user.participants.max;
      const current = user.participants.current?.length || 1;
      
      let badgeHTML = '';
      let color = '';
      let icon = '';
      let text = '';
      
      // CAS 1 : min = max (seuil obligatoire)
      if (min === max) {
        if (current >= min) {
          color = '#10B981'; // Vert
          icon = '‚úÖ';
          text = `${current}/${max} participants confirm√©s`;
        } else {
          color = '#F97316'; // Orange
          icon = '‚ö†Ô∏è';
          text = `${current}/${min} requis - Minimum NON atteint`;
        }
      }
      // CAS 2 : min < max ET min <= 2 (souple)
      else if (min <= 2) {
        color = '#10B981'; // Vert
        icon = '‚úÖ';
        text = `${min}-${max} participants (${current}/${max})`;
      }
      // CAS 3 : min < max ET min > 2 (seuil important)
      else {
        if (current >= min) {
          color = '#10B981'; // Vert
          icon = '‚úÖ';
          text = `${min}-${max} participants (${current}/${max})`;
        } else {
          color = '#FBBF24'; // Jaune
          icon = '‚ö†Ô∏è';
          text = `${min}-${max} participants (${current}/${max}) - Min ${min} requis`;
        }
      }
      
      badgeHTML = `
        <div style="font-size: 12px; margin: 6px 0; padding: 6px 8px; background: ${color}22; border-left: 3px solid ${color}; border-radius: 4px;">
          <span style="font-weight: 600;">${icon} ${text}</span>
        </div>
      `;
      
      return badgeHTML;
    }
    
    // üî• NOUVEAU : Markers avec clustering
function addMarkersWithClustering(users, zoom = 13) {
  // Clear markers existants
  if (clusteringLayer) {
    map.removeLayer(clusteringLayer);
  }
  
  markers.forEach(m => map.removeObject(m));
  markers = [];
  
  if (!users || users.length === 0) {
    console.log('Aucun utilisateur √† afficher');
    return;
  }
  
  // üî• NOUVEAU : D√©terminer eps selon zoom
  let eps;
  // üî• MODIFI√â : D√©sactiver clustering si zoom >= 14
if (zoom >= 14) {
  // Mode sans clustering : afficher pins individuels
  markers.forEach(m => map.removeObject(m));
  markers = [];
  
  users.forEach((user, index) => {
    const color = getMarkerColor(index);
    const affinityScore = user.compatibility_score || 50;
    const plan = user.plan || 'free';
    const visibility = user.visibility || 'visible';
    
    const markerIcon = new H.map.Icon(
      createDropletIcon(color, affinityScore, plan, visibility),
      {
        size: { w: 64, h: 70 },
        anchor: { x: 32, y: 66 }
      }
    );
    
    const marker = new H.map.Marker(user.location, { icon: markerIcon });
    
    marker.addEventListener('tap', function(evt) {
      const bubble = new H.ui.InfoBubble(evt.target.getGeometry(), {
        content: `
          <div style="padding: 8px; font-family: Montserrat, sans-serif;">
            <div style="font-weight: 700; font-size: 14px; margin-bottom: 4px;">
              ${escapeHTML(user.pseudo)}
            </div>
            <div style="font-size: 13px; margin-bottom: 4px;">
              ${escapeHTML(user.latest_suggestion)}
            </div>
            <div style="font-size: 12px; color: #666; margin-bottom: 4px;">
              üìç ${escapeHTML(user.city)}
            </div>
            ${generateParticipantsBadge(user)}
            <div style="font-size: 12px; font-weight: 600; color: ${getAffinityColor(affinityScore)};">
              üéØ Affinit√© : ${affinityScore}%
            </div>
          </div>
        `
      });
      ui.addBubble(bubble);
      
      highlightUserCard(index);
    });
    
    map.addObject(marker);
    markers.push(marker);
  });
  
  console.log(`‚úÖ ${users.length} pins individuels (zoom ${zoom}, sans clustering)`);
  return; // üî• IMPORTANT : Sortir de la fonction
}

// üî• Si zoom < 14 : Activer clustering
let eps;
if (zoom >= 10) {
  eps = 64; // Zoom moyen ‚Üí Clusters villes
} else if (zoom >= 6) {
  eps = 128; // Zoom loin ‚Üí Clusters r√©gions
} else {
  eps = 256; // Zoom tr√®s loin ‚Üí Clusters pays
}
  
  console.log(`üîç Zoom ${zoom} ‚Üí eps ${eps}`);
  
  // Cr√©er markers
  const dataPoints = users.map((user, index) => {
    const color = getMarkerColor(index);
    const affinityScore = user.compatibility_score || 50;
    const plan = user.plan || 'free';
    const visibility = user.visibility || 'visible';
    
    return new H.clustering.DataPoint(
      user.location.lat,
      user.location.lng,
      null,
      { user, index, color, affinityScore, plan, visibility }
    );
  });
  
  // üî• Clustering provider
  const clusteredDataProvider = new H.clustering.Provider(dataPoints, {
    clusteringOptions: {
      eps,
      minWeight: 1
    },
    theme: {
      getClusterPresentation: function(cluster) {
        const clusterMarker = new H.map.Marker(cluster.getPosition(), {
          icon: new H.map.Icon(createClusterIcon(cluster.getWeight()), {
            size: { w: 60, h: 60 },
            anchor: { x: 30, y: 30 }
          }),
          min: cluster.getMinZoom(),
          max: cluster.getMaxZoom()
        });
        
        clusterMarker.setData(cluster);
        
        // üî• NOUVEAU : Clic sur cluster ‚Üí Zoom
        clusterMarker.addEventListener('tap', () => {
          const clusterBounds = cluster.getBoundingBox();
          if (clusterBounds) {
            map.getViewModel().setLookAtData({ bounds: clusterBounds });
            map.setZoom(map.getZoom() + 2);
          }
        });
        
        return clusterMarker;
      },
      getNoisePresentation: function(noisePoint) {
        const data = noisePoint.getData();
        const markerIcon = new H.map.Icon(
          createDropletIcon(data.color, data.affinityScore, data.plan, data.visibility),
          {
            size: { w: 64, h: 70 },
            anchor: { x: 32, y: 66 }
          }
        );
        
        const noiseMarker = new H.map.Marker(noisePoint.getPosition(), {
          icon: markerIcon,
          min: noisePoint.getMinZoom()
        });
        
        noiseMarker.setData(data);
        
        noiseMarker.addEventListener('tap', function(evt) {
          const markerData = evt.target.getData();
          const user = markerData.user;
          
          const bubble = new H.ui.InfoBubble(evt.target.getGeometry(), {
            content: `
        <div style="padding: 8px; font-family: Montserrat, sans-serif;">
          <div style="font-weight: 700; font-size: 14px; margin-bottom: 4px;">
            ${escapeHTML(user.pseudo)}
          </div>
          <div style="font-size: 13px; margin-bottom: 4px;">
            ${escapeHTML(user.latest_suggestion)}
          </div>
          <div style="font-size: 12px; color: #666; margin-bottom: 4px;">
            üìç ${escapeHTML(user.city)}
          </div>
          ${generateParticipantsBadge(user)}
          <div style="font-size: 12px; font-weight: 600; color: ${getAffinityColor(markerData.affinityScore)};">
            üéØ Affinit√© : ${markerData.affinityScore}%
          </div>
        </div>
            `
          });
          ui.addBubble(bubble);
          
          highlightUserCard(markerData.index);
        });
        
        return noiseMarker;
      }
    }
  });
  
  clusteringLayer = new H.map.layer.ObjectLayer(clusteredDataProvider);
  map.addLayer(clusteringLayer);
  
  console.log(`‚úÖ ${users.length} users avec clustering (eps: ${eps})`);
}
    
    function populateUserCards(users, zoom = 13) {
  const grid = document.getElementById('usersGrid');
  grid.innerHTML = '';
  
  // üî• NOUVEAU : Si zoom < 10, masquer cartes et afficher message
  if (zoom < 10) {
    grid.innerHTML = '<div style="padding: 32px; color: var(--mt-muted); text-align: center; width: 100%; font-size: 16px;">üîç Zoomez pour voir les profils MeeTempers</div>';
    return;
  }
  
  if (users.length === 0) {
        grid.innerHTML = '<div style="padding: 20px; color: var(--mt-muted); text-align: center; width: 100%;">Aucun MeeTemper √† proximit√©</div>';
        return;
      }
      
      users.forEach((user, index) => {
        const card = document.createElement('div');
        card.className = 'user-card';
        card.dataset.index = index;
        
        const initials = escapeHTML(user.pseudo.substring(0, 2).toUpperCase());
        const pseudo = escapeHTML(user.pseudo);
        const suggestion = escapeHTML(user.latest_suggestion);
        const city = escapeHTML(user.city);
        const distance = user.distance ? `${user.distance} km` : '√Ä proximit√©';
        const affinityScore = user.compatibility_score || 50;
        
        card.innerHTML = `
          <div class="user-header">
            <div class="user-avatar">${initials}</div>
            <div class="user-info">
              <h3>${pseudo}</h3>
              <div class="user-distance">${distance} ‚Ä¢ ${affinityScore}%</div>
            </div>
          </div>
          <div class="user-suggestion">${suggestion}</div>
          <div class="user-location">üìç ${city}</div>
          <div class="user-actions">
            <button class="btn btn-primary" onclick="contactUser('${user.id}')">üí¨ Contacter</button>
            <button class="btn btn-secondary" onclick="viewProfile('${user.id}')">üëÄ Profil</button>
          </div>
        `;
        
        card.onclick = function() {
          centerOnUser(index);
        };
        
        grid.appendChild(card);
      });
    }
    
    function highlightUserCard(index) {
      document.querySelectorAll('.user-card').forEach(c => c.classList.remove('active'));
      const card = document.querySelector(`.user-card[data-index="${index}"]`);
      if (card) {
        card.classList.add('active');
        card.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' });
      }
    }
    
    function centerOnUser(index) {
      if (usersData[index]) {
        map.setCenter(usersData[index].location);
        map.setZoom(15);
        highlightUserCard(index);
      }
    }
    
    function contactUser(userId) {
      alert('üí¨ Messagerie en d√©veloppement\n\nLa messagerie arrive bient√¥t !');
    }
    
    function viewProfile(userId) {
      alert('üëÄ Profil d√©taill√© en d√©veloppement');
    }
    
    async function toggleVisibility() {
      currentVisibility = currentVisibility === 'visible' ? 'discret' : 'visible';
      
      const icon = document.getElementById('visibilityIcon');
      const text = document.getElementById('visibilityText');
      const toggle = document.getElementById('visibilityToggle');
      
      if (currentVisibility === 'discret') {
        icon.textContent = 'üï∂Ô∏è';
        text.textContent = 'Discret';
        toggle.style.background = 'rgba(59, 130, 246, 0.2)';
        toggle.style.borderColor = '#3B82F6';
      } else {
        icon.textContent = 'üëÅÔ∏è';
        text.textContent = 'Visible';
        toggle.style.background = 'rgba(255,255,255,0.1)';
        toggle.style.borderColor = 'rgba(255,255,255,0.2)';
      }
      
      try {
        await fetch(`${API_BASE}/profile/update?token=${token}&visibility=${currentVisibility}`);
        console.log(`‚úÖ Mode ${currentVisibility}`);
      } catch (err) {
        console.error('‚ùå Erreur:', err);
      }
    }

    // üî• NOUVEAU : Recentrer sur ma position
function goToMyLocation() {
  if (userGpsLocation && userGpsLocation.source === 'gps') {
    // üî• Utiliser userGpsLocation (position r√©elle)
    const position = { lat: userGpsLocation.lat, lng: userGpsLocation.lng };
    
    map.setCenter(position);
    map.setZoom(14);
    
    // üî• NOUVEAU : Forcer mise √† jour currentLocation + recharger
    currentLocation = { ...userGpsLocation };
    loadNearbyUsers();
    
    console.log(`üéØ Recentr√© sur GPS: ${position.lat}, ${position.lng}`);
  } else {
    // Redemander g√©olocalisation
    if (navigator.geolocation) {
      navigator.geolocation.getCurrentPosition(
        (position) => {
          userGpsLocation = {  // üî• MODIFI√â : Sauvegarder GPS
            lat: position.coords.latitude,
            lng: position.coords.longitude,
            source: 'gps',
            accuracy: position.coords.accuracy
          };
          
          currentLocation = { ...userGpsLocation };
          const pos = { lat: currentLocation.lat, lng: currentLocation.lng };
          map.setCenter(pos);
          map.setZoom(14);
          loadNearbyUsers();
          
          console.log(`üéØ Position GPS rafra√Æchie: ${pos.lat}, ${pos.lng}`);
        },
        (error) => {
          alert('‚ùå Impossible d\'acc√©der √† votre position GPS');
          console.error('Geoloc error:', error);
        },
        { timeout: 5000, enableHighAccuracy: true }
      );
    } else {
      alert('‚ùå G√©olocalisation non disponible');
    }
  }
}
// üî• NOUVEAU : Mettre √† jour indicateur ville (reverse geocoding)
async function updateLocationIndicator(lat, lng) {
  try {
    // üî• NOUVEAU : Throttle 1.2s minimum entre appels
    const now = Date.now();
    if (now - lastReverseGeocodingCall < 1200) {
      console.log('‚è≥ Throttle reverse geocoding (1.2s)');
      return;
    }
    lastReverseGeocodingCall = now;
    
    // üî• NOUVEAU : Cache 5min (arrondi 0.01¬∞ ‚âà 1km)
    const cacheKey = `city_${lat.toFixed(2)}_${lng.toFixed(2)}`;
    const cached = sessionStorage.getItem(cacheKey);
    
    if (cached) {
      const { city, timestamp } = JSON.parse(cached);
      if (Date.now() - timestamp < 300000) { // 5min
        document.getElementById('locationText').textContent = city;
        currentLocation.city = city;
        console.log(`üìç Ville (cache): ${city}`);
        return;
      }
    }
    
    // Appel API HERE
    const reverseUrl = `https://revgeocode.search.hereapi.com/v1/revgeocode?at=${lat},${lng}&apiKey=${HERE_API_KEY}`;
    const response = await fetch(reverseUrl);
    
    if (!response.ok) {
      console.warn('‚ö†Ô∏è Reverse geocoding √©chou√©');
      return;
    }
    
    const data = await response.json();
    
    if (data.items && data.items.length > 0) {
      const address = data.items[0].address;
      const cityName = address.city || address.county || address.state || 'Lieu inconnu';
      
      // Mettre √† jour indicateur
      document.getElementById('locationText').textContent = cityName;
      currentLocation.city = cityName;
      
      // üî• NOUVEAU : Sauvegarder en cache
      sessionStorage.setItem(cacheKey, JSON.stringify({
        city: cityName,
        timestamp: Date.now()
      }));
      
      console.log(`üìç Ville mise √† jour (API): ${cityName}`);
    }
    
  } catch (err) {
    console.error('‚ùå Erreur reverse geocoding:', err);
  }
}

    init();
  </script>
</body>
</html>
